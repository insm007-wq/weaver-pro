/**
 * ProgressIndicator - ÏßÑÌñâÎ•† ÌëúÏãú Ïª¥Ìè¨ÎÑåÌä∏
 * 
 * @description
 * Îã§ÏñëÌïú ÌòïÌÉúÏùò ÏßÑÌñâÎ•†ÏùÑ ÌëúÏãúÌïòÎäî Ïª¥Ìè¨ÎÑåÌä∏ÏûÖÎãàÎã§.
 * Fluent UI ProgressBarÎ•º Í∏∞Î∞òÏúºÎ°ú ÌôïÏû• Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
 * 
 * @features
 * - üìä ÏÑ†Ìòï/ÏõêÌòï ÏßÑÌñâÎ•† ÌëúÏãú
 * - üé® Îã§ÏñëÌïú ÏÉâÏÉÅ ÌÖåÎßà
 * - üìè ÌÅ¨Í∏∞ ÏòµÏÖò
 * - ‚è±Ô∏è Ïï†ÎãàÎ©îÏù¥ÏÖò Ìö®Í≥º
 * - üîß ÏôÑÏ†ÑÌûà Ïª§Ïä§ÌÑ∞ÎßàÏù¥Ïßï Í∞ÄÎä•
 * 
 * @author Weaver Pro Team
 * @version 2.0.0
 */

import React, { memo, useMemo } from 'react';
import {
  makeStyles,
  shorthands,
  tokens,
  ProgressBar,
  Text,
  mergeClasses
} from '@fluentui/react-components';

const useStyles = makeStyles({
  // Ïª®ÌÖåÏù¥ÎÑà Ïä§ÌÉÄÏùº
  container: {
    display: 'flex',
    flexDirection: 'column',
    ...shorthands.gap(tokens.spacingVerticalS),
  },

  // Ïù∏ÎùºÏù∏ Ïª®ÌÖåÏù¥ÎÑà
  inlineContainer: {
    display: 'flex',
    alignItems: 'center',
    ...shorthands.gap(tokens.spacingHorizontalM),
  },

  // Î†àÏù¥Î∏î Ïä§ÌÉÄÏùº
  label: {
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightSemibold,
    color: tokens.colorNeutralForeground1,
  },

  // ÏûëÏùÄ Î†àÏù¥Î∏î
  smallLabel: {
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightRegular,
    color: tokens.colorNeutralForeground2,
  },

  // Í∞í ÌëúÏãú
  valueDisplay: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: tokens.spacingVerticalXS,
  },

  // ÌçºÏÑºÌä∏ ÌÖçÏä§Ìä∏
  percentage: {
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightSemibold,
    color: tokens.colorNeutralForeground2,
  },

  // ÏÉÅÏÑ∏ Ï†ïÎ≥¥
  details: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    fontSize: tokens.fontSizeBase100,
    color: tokens.colorNeutralForeground3,
    marginTop: tokens.spacingVerticalXS,
  },

  // ÏõêÌòï ÏßÑÌñâÎ•† Ïª®ÌÖåÏù¥ÎÑà
  circularContainer: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    ...shorthands.gap(tokens.spacingVerticalS),
  },

  // ÏõêÌòï ÏßÑÌñâÎ•† SVG
  circularProgress: {
    transform: 'rotate(-90deg)',
    transition: 'all 0.3s ease',
  },

  // ÏõêÌòï ÏßÑÌñâÎ•† ÌÖçÏä§Ìä∏
  circularText: {
    position: 'absolute',
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightSemibold,
    color: tokens.colorNeutralForeground1,
    textAlign: 'center',
  },

  // ÏûëÏùÄ ÏõêÌòï ÌÖçÏä§Ìä∏
  smallCircularText: {
    fontSize: tokens.fontSizeBase200,
  },

  // ÌÅ∞ ÏõêÌòï ÌÖçÏä§Ìä∏
  largeCircularText: {
    fontSize: tokens.fontSizeBase400,
  },

  // Ïä§ÌÖù ÏßÑÌñâÎ•† Ïª®ÌÖåÏù¥ÎÑà
  stepsContainer: {
    display: 'flex',
    flexDirection: 'column',
    ...shorthands.gap(tokens.spacingVerticalM),
  },

  // Ïä§ÌÖù Ìó§Îçî
  stepsHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
  },

  // Ïä§ÌÖù Î¶¨Ïä§Ìä∏
  stepsList: {
    display: 'flex',
    alignItems: 'center',
    ...shorthands.gap(tokens.spacingHorizontalS),
  },

  // Ïä§ÌÖù ÏïÑÏù¥ÌÖú
  stepItem: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: '24px',
    height: '24px',
    ...shorthands.borderRadius('50%'),
    fontSize: tokens.fontSizeBase100,
    fontWeight: tokens.fontWeightSemibold,
    transition: 'all 0.2s ease',
  },

  // ÏôÑÎ£åÎêú Ïä§ÌÖù
  completedStep: {
    backgroundColor: tokens.colorPaletteGreenBackground3,
    color: tokens.colorNeutralForegroundOnBrand,
  },

  // ÌòÑÏû¨ Ïä§ÌÖù
  currentStep: {
    backgroundColor: tokens.colorBrandBackground,
    color: tokens.colorNeutralForegroundOnBrand,
  },

  // ÎØ∏ÏôÑÎ£å Ïä§ÌÖù
  pendingStep: {
    backgroundColor: tokens.colorNeutralBackground3,
    color: tokens.colorNeutralForeground3,
    ...shorthands.border('1px', 'solid', tokens.colorNeutralStroke2),
  },

  // Ïä§ÌÖù Ïó∞Í≤∞ÏÑ†
  stepConnector: {
    flex: 1,
    height: '2px',
    backgroundColor: tokens.colorNeutralStroke2,
    position: 'relative',
    
    '::before': {
      content: '""',
      position: 'absolute',
      top: 0,
      left: 0,
      height: '100%',
      backgroundColor: tokens.colorPaletteGreenBackground3,
      transition: 'width 0.3s ease',
    },
  },
});

/**
 * ProgressIndicator Ïª¥Ìè¨ÎÑåÌä∏
 * 
 * @param {Object} props - Ïª¥Ìè¨ÎÑåÌä∏ ÏÜçÏÑ±
 * @param {'linear'|'circular'|'steps'} [props.type='linear'] - ÏßÑÌñâÎ•† ÌëúÏãú ÌÉÄÏûÖ
 * @param {number} [props.value=0] - ÌòÑÏû¨ Í∞í
 * @param {number} [props.max=100] - ÏµúÎåÄ Í∞í
 * @param {string} [props.label] - Î†àÏù¥Î∏î ÌÖçÏä§Ìä∏
 * @param {boolean} [props.showPercentage=true] - ÌçºÏÑºÌä∏ ÌëúÏãú Ïó¨Î∂Ä
 * @param {boolean} [props.showValues=false] - Í∞í ÌëúÏãú Ïó¨Î∂Ä
 * @param {boolean} [props.inline=false] - Ïù∏ÎùºÏù∏ Î†àÏù¥ÏïÑÏõÉ
 * @param {'small'|'medium'|'large'} [props.size='medium'] - ÌÅ¨Í∏∞
 * @param {'default'|'success'|'warning'|'error'} [props.color='default'] - ÏÉâÏÉÅ
 * @param {Array} [props.steps] - Ïä§ÌÖù Ï†ïÎ≥¥ (steps ÌÉÄÏûÖÏö©)
 * @param {number} [props.currentStep] - ÌòÑÏû¨ Ïä§ÌÖù (steps ÌÉÄÏûÖÏö©)
 * @param {string} [props.description] - ÏÑ§Î™Ö ÌÖçÏä§Ìä∏
 * @param {string} [props.className] - Ï∂îÍ∞Ä CSS ÌÅ¥ÎûòÏä§
 * @returns {JSX.Element} ProgressIndicator Ïª¥Ìè¨ÎÑåÌä∏
 */
function ProgressIndicator({
  type = 'linear',
  value = 0,
  max = 100,
  label,
  showPercentage = true,
  showValues = false,
  inline = false,
  size = 'medium',
  color = 'default',
  steps = [],
  currentStep = 0,
  description,
  className = '',
  ...props
}) {
  const styles = useStyles();

  // ÌçºÏÑºÌä∏ Í≥ÑÏÇ∞
  const percentage = useMemo(() => {
    return Math.min(Math.max((value / max) * 100, 0), 100);
  }, [value, max]);

  // Ìè¨Îß∑Îêú ÌçºÏÑºÌä∏
  const formattedPercentage = useMemo(() => {
    return Math.round(percentage);
  }, [percentage]);

  // ÏÑ†Ìòï ÏßÑÌñâÎ•† Î†åÎçîÎßÅ
  const renderLinearProgress = () => {
    const containerClass = inline ? styles.inlineContainer : styles.container;

    return (
      <div className={mergeClasses(containerClass, className)}>
        {(label || showPercentage || showValues) && (
          <div className={styles.valueDisplay}>
            {label && (
              <Text className={size === 'small' ? styles.smallLabel : styles.label}>
                {label}
              </Text>
            )}
            <div style={{ display: 'flex', alignItems: 'center', gap: tokens.spacingHorizontalS }}>
              {showValues && (
                <Text className={styles.percentage}>
                  {value}/{max}
                </Text>
              )}
              {showPercentage && (
                <Text className={styles.percentage}>
                  {formattedPercentage}%
                </Text>
              )}
            </div>
          </div>
        )}
        
        <ProgressBar 
          value={percentage} 
          max={100}
          thickness={size === 'small' ? 'medium' : size}
          {...props}
        />
        
        {description && (
          <div className={styles.details}>
            <Text>{description}</Text>
          </div>
        )}
      </div>
    );
  };

  // ÏõêÌòï ÏßÑÌñâÎ•† Î†åÎçîÎßÅ
  const renderCircularProgress = () => {
    const circleSize = size === 'small' ? 60 : size === 'large' ? 100 : 80;
    const strokeWidth = size === 'small' ? 4 : size === 'large' ? 8 : 6;
    const radius = (circleSize - strokeWidth) / 2;
    const circumference = 2 * Math.PI * radius;
    const strokeDasharray = circumference;
    const strokeDashoffset = circumference - (percentage / 100) * circumference;

    const getStrokeColor = () => {
      switch (color) {
        case 'success': return tokens.colorPaletteGreenBackground3;
        case 'warning': return tokens.colorPaletteYellowBackground3;
        case 'error': return tokens.colorPaletteRedBackground3;
        default: return tokens.colorBrandBackground;
      }
    };

    return (
      <div className={mergeClasses(styles.circularContainer, className)}>
        {label && (
          <Text className={size === 'small' ? styles.smallLabel : styles.label}>
            {label}
          </Text>
        )}
        
        <div style={{ position: 'relative', width: circleSize, height: circleSize }}>
          <svg 
            className={styles.circularProgress}
            width={circleSize} 
            height={circleSize}
          >
            {/* Î∞∞Í≤Ω Ïõê */}
            <circle
              cx={circleSize / 2}
              cy={circleSize / 2}
              r={radius}
              stroke={tokens.colorNeutralStroke2}
              strokeWidth={strokeWidth}
              fill="transparent"
              strokeLinecap="round"
            />
            {/* ÏßÑÌñâÎ•† Ïõê */}
            <circle
              cx={circleSize / 2}
              cy={circleSize / 2}
              r={radius}
              stroke={getStrokeColor()}
              strokeWidth={strokeWidth}
              fill="transparent"
              strokeLinecap="round"
              strokeDasharray={strokeDasharray}
              strokeDashoffset={strokeDashoffset}
              style={{ 
                transition: 'stroke-dashoffset 0.5s ease',
                transformOrigin: 'center'
              }}
            />
          </svg>
          
          <div className={mergeClasses(
            styles.circularText,
            size === 'small' && styles.smallCircularText,
            size === 'large' && styles.largeCircularText
          )}>
            {showPercentage ? `${formattedPercentage}%` : `${value}/${max}`}
          </div>
        </div>
        
        {description && (
          <Text style={{ textAlign: 'center', maxWidth: circleSize + 20 }}>
            {description}
          </Text>
        )}
      </div>
    );
  };

  // Ïä§ÌÖù ÏßÑÌñâÎ•† Î†åÎçîÎßÅ
  const renderStepsProgress = () => {
    return (
      <div className={mergeClasses(styles.stepsContainer, className)}>
        {label && (
          <div className={styles.stepsHeader}>
            <Text className={styles.label}>{label}</Text>
            <Text className={styles.percentage}>
              {currentStep + 1}/{steps.length}
            </Text>
          </div>
        )}
        
        <div className={styles.stepsList}>
          {steps.map((step, index) => {
            const isCompleted = index < currentStep;
            const isCurrent = index === currentStep;
            const isPending = index > currentStep;
            
            return (
              <React.Fragment key={index}>
                <div 
                  className={`${styles.stepItem} ${
                    isCompleted ? styles.completedStep :
                    isCurrent ? styles.currentStep :
                    styles.pendingStep
                  }`}
                  title={step.title || `Step ${index + 1}`}
                >
                  {isCompleted ? '‚úì' : index + 1}
                </div>
                
                {index < steps.length - 1 && (
                  <div 
                    className={styles.stepConnector}
                    style={{
                      '::before': {
                        width: isCompleted ? '100%' : '0%'
                      }
                    }}
                  />
                )}
              </React.Fragment>
            );
          })}
        </div>
        
        {description && (
          <Text className={styles.details}>{description}</Text>
        )}
      </div>
    );
  };

  // ÌÉÄÏûÖÎ≥Ñ Î†åÎçîÎßÅ
  switch (type) {
    case 'circular':
      return renderCircularProgress();
    case 'steps':
      return renderStepsProgress();
    default:
      return renderLinearProgress();
  }
}

// =========================== ÌäπÌôîÎêú ÏßÑÌñâÎ•† Ïª¥Ìè¨ÎÑåÌä∏Îì§ ===========================

/**
 * ÏõêÌòï ÏßÑÌñâÎ•† ÌëúÏãúÍ∏∞
 */
export function CircularProgress(props) {
  return <ProgressIndicator type="circular" {...props} />;
}

/**
 * Ïä§ÌÖù ÏßÑÌñâÎ•† ÌëúÏãúÍ∏∞
 */
export function StepsProgress(props) {
  return <ProgressIndicator type="steps" {...props} />;
}

/**
 * Í∞ÑÎã®Ìïú ÏßÑÌñâÎ•† Î∞î
 */
export function SimpleProgress({ value, max = 100, ...props }) {
  return (
    <ProgressIndicator 
      value={value}
      max={max}
      showPercentage={false}
      showValues={false}
      {...props}
    />
  );
}

/**
 * ÏóÖÎ°úÎìú ÏßÑÌñâÎ•† ÌëúÏãúÍ∏∞
 */
export function UploadProgress({ 
  value, 
  max = 100, 
  filename, 
  speed,
  ...props 
}) {
  const description = speed ? `${filename} - ${speed}/s` : filename;
  
  return (
    <ProgressIndicator 
      type="linear"
      value={value}
      max={max}
      label="ÌååÏùº ÏóÖÎ°úÎìú"
      description={description}
      showPercentage
      color="success"
      {...props}
    />
  );
}

export default memo(ProgressIndicator);